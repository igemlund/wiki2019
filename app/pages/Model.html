<!-- index.html -->
{% extends "layout.html" %}
{% block content %} 
{% include "partials/header.nunjucks" %}
<h1 id="title" class="js-toc-ignore">Mathematical Models</h1>
<div id="body">
<h1 class="js-toc-ignore">STACC</h1>
    <p>We here present our machine learning algorithm STAAC. STAAC is a combination of two neural networks and a tree-based model that when integrated into a genetic algorithm can generate peptides with different antimicrobial properties by classifying them into the categories antifungal (AFP), non-antifungal antimicrobial (NoAFP-AMP), and non-antimicrobial (NoAMP). The categories are illustrated in the Venn diagram below:
        </p>
<br>
<p>The objective of STAAC is to generate new, previously unseen peptides that would suit our project of producing anti-oomycete peptides in bacteria. This means that the peptides should have strong antifungal and therefore anti-oomycete, properties, while at the same time having weak antibacterial properties. STAAC is therefore trained to maximize the harmonic mean (HM) of the AFP classification precision and the NoAFP-AMP classification recall. Overall, STAAC can classify unseen peptides with an accuracy of 88 %, AFPs with a precision of 88 %, and NoAFP-AMPs with a recall of 65 %. We would like to stress that there are models out there with much better accuracy and precision if one would like to answer the binary question: “Is this peptide antifungal?”. Indeed, when we converted our model to answer this binary question, we received a precision of 93.5 % and an overall accuracy of 94 %.</p>

<h2 id="js-toc-ignore">Theory</h2>
<p>The STAAC model is a combination of a Random Forest Classifier and two neural networks, combined using a Support Vector Machine. </p>
<br>
<h3 id="js-toc-ignore">Random Forest Classifiers:</h3>
<p>The Random Forest Classifier (RFC) is a so-called ensemble learning algorithm, meaning it consists of several preliminary algorithms merged into one. In the case of the RFCs, these preliminary algorithms are decision tree classifiers. The decision tree classifier is a binary tree where each node is a binary condition (ex. Is peptide length > 20 peptides) and each leaf is a predicted label. A prediction is generated by passing the features through the tree, from the root to the leaves by answering these binary conditions. The RFC supplies a randomly chosen subset of the training features to each of its decision trees and then comes up with a prediction based on the majority vote of the individual trees. This randomized behavior of the RFC does very well in tackling the otherwise great issue of overfitting that comes with a simple decision tree. A more in-depth explanation of the RFC can be found <a href="https://en.wikipedia.org/wiki/Random_forest">here</a>.</p>
<h3 id="js-toc-ignore">Neural Networks:</h3>
<p>Neural networks are becoming increasingly popular in bioinformatics. This is due to their ability to handle a huge number of features without overfitting. They are also very capable of finding non-linear patterns in the data. The input is here passed through layers of nodes by edges connecting one layer to the next. Each edge has a weight and each node has an activation function. This means that the number of fitted parameters often becomes very large (about n_{nodes}^2 * n_{layers}) and it is seldom possible for a human to understand the operations performed by the network. This leads to the obvious downside with neural networks; it’s often very hard to figure out what kind of pattern the network finds. There are several great resources to further deepen your understanding of neural networks,<a href="https://en.wikipedia.org/wiki/Artificial_neural_network">for example</a>.  </p>
<h3 id="js-toc-ignore">SVM:</h3>
 <p>The Support Vector Machine is a common supervised machine learning algorithm when dealing with classification problems. The algorithm works by constructing hyperplanes, maximizing the margin between the data points of each classification label closest to one another, also called the support vectors. This is mainly done by constructing a linear plane or, when the data is nonlinear, by increasing the dimensions of the data. A great explanation can be found on <a href="(https://www.datacamp.com/community/tutorials/svm-classification-scikit-learn-python#svm">DataCamp</a>.</p>
<h3 id="js-toc-ignore">Metrics:</h3>
 <p>In our case, we had an issue with an unbalanced data set. While having about 8000 peptides labelled as “non-antimicrobial”, we had about 3000 AMPs and only about 500 labelled as “non-antifungal - antimicrobial”. If one would use the overall accuracy of the model to evaluate the performance, then an algorithm classifying everything as NoAMP would get a 70 % accuracy. If it manages to correctly differentiate between AFPs and NoAFPs but completely ignores NoAFPAMPs, we will get an overall accuracy of 95 %! To overcome this, it’s often good practice to use precision, recall, or f1-score instead, all of which can be defined through the confusion matrix:</p>
<button type="button" class="collapsible">&darr; Table 1: Confusion matrix in binary classification: </button>
<table>
  <tr>
    <th>      </th>
    <th>True 1</th>
    <th>True 0</th>
  </tr>
  <tr>
      <td><b><i>Predicted 1</i></b></td>
      <td>True positive (TP).</td>
      <td>False-positive (FP).</td>
  </tr>
  <tr>
      <td><b><i>Predicted 0</i></b></td>
      <td>False-negative (FN).</td>
      <td>True negative (TN).</td>
  </tr>
</table>
<p></p>

<br>
<button type="button" class="collapsible">&darr; Table 2: Confusion matrix in Multilabel classification</button>
<table>
  <tr>
    <th>      </th>
    <th>True A</th>
    <th>True B</th>
    <th>True C</th>
  </tr>
  <tr>
      <td><b>Predicted a</b></td>
      <td>Aa</td>
      <td>Ba</td>
      <td>Ca</td>
  </tr>
  <tr>
    <td><b>Predicted b</b></td>
    <td>Ab</td>
    <td>Bb</td>
    <td>Cb</td>
  </tr>
  <tr>
    <td><b>Predicted c</b></td>
    <td>Ca</td>
    <td>Cb</td>
    <td>Cc</td>
  </tr>
</table>
<h3 id="js-toc-ignore">Multilabel metrics:</h3>
<p>Which metric to use depends on the objective of the model. When dealing with a multilabel dataset, one gets even more alternatives. One could look at global metrics such as the macro-average or micro-average of multilabel metrics such as precision and recall, or individual metrics of each label. </p>
<p>Given the stated issues and challenges when choosing a metric as well as the purpose of the STAAC model of generating new peptides with high antifungal properties and low antibacterial properties, we decided to mainly monitor the precision of the AFP-classification and the recall of the NoAFPAMP-classification. A logical way of combining the two metrics into one is taking the harmonic average, similar to how one computes the commonly used f1-score. 
</p>
<p>Optimizing the AFP-classification precision results in a model that strongly punishes “risky” patterns that may misclassify peptides as AFPs. We hypothesize that this would be analogous to the model promoting only strong antifungal properties in peptides. Optimizing the NoAFPAMP-classification recall results in a model that more strongly classifies peptides as NoAFPAMPs. We hypothesize that this is analogous to the model promoting non-antifungal, antimicrobial properties, classifying even the weak properties as NoAFPAMP. Knowing that the model is more sensitive to promoting AFPs and more strongly promotes NoAFPAMPs we hypothesize that if we then maximize the predicted probability of a given peptide being an AFP and minimize the probability of it being a NoAFPAMP, we will be able to generate peptides with high antifungal properties and low antibacterial properties. </p>
<h2 id="js-toc-ignore">Method</h2>
<h3 id="js-toc-ignore">Data Management:</h3>
<p>Peptides were imported, cleaned, and sorted into the groups “Antifungal peptides” (AFPs), “Non-antifungal, antimicrobial peptides” (NoAFP-AMPs), and “Non-antimicrobial peptides” (NoAMPs). Peptides with a length between 10 and 50, inclusive, were selected. Peptides with missing information on their antifungal properties were not removed but classified as not having antifungal properties. Not removing peptides with missing data was a mistake which probably resulted in a worse model. A limited schedule is to blame for why this issue persists.</p>
<p>120 AFPs, 20 NoAFP-AMPs, and 100 NoAMPs were randomly chosen to be moved to a holdout data set. The remaining 11563 peptides were randomly split into two groups: 80 % to a data set used to train the first three independent classifiers (Sequential Model, Trigrams Model, PseAAC Model), and 20 % to a data set used to train the SVM. The complete distribution of peptides can be seen in the table below. </p>
<br>
<button type="button" class="collapsible">&darr; Table 3: The complete distribution of peptides</button>
<table>
  <tr>
    <th>      </th>
    <th>AFP</th>
    <th>NoAFP-AMP</th>
    <th>NoAMP</th>
  </tr>
  <tr>
      <td><b>Classifier Training</b></td>
      <td>4317</td>
      <td>506</td>
      <td>5995</td>
  </tr>
  <tr>
    <td><b>SVM Training</b></td>
    <td>1079</td>
    <td>126</td>
    <td>1499</td>
  </tr>
  <tr>
    <td><b>Holdout Data</b></td>
    <td>120</td>
    <td>20</td>
    <td>100</td>
  </tr>
</table>
<h2 id="js-toc-ignore">Feature extraction:</h2>
<p>Features were extracted from the peptide strings in three different ways:</p>
<h3 id="js-toc-ignore">Sequential Transformation:</h3>
<p>Each given string of amino acids was transformed into a 50 x 20 binary matrix where the 50 rows represented each position in the string and the 20 columns represented the 20 possible values at each position. The string “ABD” would hence be transformed into a 50 x 20 matrix of zeros with ones at the positions (0,0), (1,1), and (2,3). The matrices were then flattened into a single list of binary values. Using a <a href="(https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html?highlight=standard%20scaler#sklearn.preprocessing.StandardScaler">sklearn Standard Scaler</a>, the data was normalized.  </p>
<h3 id="js-toc-ignore">Ngrams Transformation:</h3>
<p>Mono-, bi- and trigrams were extracted from the strings using <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html">sklearn CountVectorizer</a> analyzing characters with a fixed vocabulary. The three transformations were concatenated. Using a sklearn Standard Scaler, the data was normalized. </p>
<h3 id="js-toc-ignore"> PseAAC:</h3>
<p>The Pseudo amino acid composition of each peptide was computed using lambda = 2 and for every 63 combinations of the six amino acid properties 'Hydrophobicity', 'hydrophilicity', 'residue mass', 'pK1', 'pK2' and 'pI' using <a href="https://github.com/gadsbyfly/PyBioMed">PyBioMed </a>. </p>
<p>This resulted in a 63 x 22 matrix that was then flattened into a single list. Using a sklearn Standard Scaler, the data was normalized. Similar to (https://www.worldscientific.com/doi/abs/10.1142/S0219720018500166) features were then selected using recursive feature elimination, removing two features at a time. Here sklearn RFE was used with an inversely weighted sklearn Random Forest Classifier. 400 of the 1386 features were selected. </p>
<h2 id="js-toc-ignore">Model creation:</h2>
<p>Four different models were created; two neural networks, trained on the sequentially transformed data and the mono-, bi- and trigrams data respectively, a random forest classifier, trained on the PseAAC data, and an SVC, used to combine the three previously mentioned models. </p>
<h4 class="js-toc-ignore" class="js-toc-ignore">Sequential Model:</h4>
<p> A neural network was built using <a href="https://www.tensorflow.org/guide/keras/sequential_model">TensorFlow.Keras</a>:
<ul>
<li>Layers: 3 dense layers</li>
<li>Nodes: 10 per layer</li>
<li>Activation function: ReLu</li>
<li>Regularization: L2, L=0.05</li>
<li>Output layer: 3 nodes, activation: sigmoid</li>
<li>Optimizer: Adam</li>
<li>Loss function: Binary Crossentropy</li>
</ul></p>
<p class="fig">The model was trained on the designated 80 % of the sequentially transformed data, inversely weighted, for 12 epochs.</p>
<br>
<h4 class="js-toc-ignore" class="js-toc-ignore">Ngrams Model:</h4>
<p> A neural network was built using <a href="https://www.tensorflow.org/guide/keras/sequential_model">TensorFlow.Keras</a>:
<ul>
<li>Layers: 3 dense layers with 30 % dropout</li>
<li>Nodes: 10 per layer</li>
<li>Activation function: ReLu</li>
<li>Regularization: L2, L=0.01</li>
<li>Output layer: 3 nodes, activation: sigmoid</li>
<li>Optimizer: Adam</li>
<li>Loss function: Binary Crossentropy</li>
</ul></p>
<p class="fig">The model was trained on the designated 80 % of the mono-, bi- and trigrams transformed data, inversely weighted, for 4 epochs. </p>
<br>
<h2 id="js-toc-ignore">PseAAC Model:</h2>
<pr>The designated 80 % of the PseAAC data was used to train a Random Forest Classifier (200 estimators, maximum depth of each tree: 20 nodes, maximum number of features supplied to each tree: 9, minimum samples per leaf: 4, criterion: entropy). The training data was inversely weighted to account for label imbalance. </pr>
<br>
<h2 id="js-toc-ignore">SVM Model:</h2>
<p>The designated 20 % of the peptides were used to generate predictions from the three different previously described models. The models’ predictions were concatenated into a 3x3 matrix. The column describing the predictions of NoAFP-AMP was dropped to reduce the number of features, resulting in a 3x2 matrix that was then flattened to a 6x1 list. The data was inversely weighted and used to train a sklearn SVC using an RBF kernel (gamma=0.1).</p>
<br>
  


<br>
<button type="button" class="collapsible">&darr; Table 4: Results</button>
<table>
  <tr>
    <th>      </th>
    <th>Training Accuracy</th>
    <th>Test Accuracy</th>
    <th>AFP Precision</th>
    <th>NoAFPAMP Precision</th>
    <th>AFP Recall</th>
    <th>NoAFPAMP Recall</th>
    <th>HM</th>
  </tr>
  <tr>
      <td><b>Sequential Model</b></td>
      <td>0.74</td>
      <td>0.70</td>
      <td>0.65</td>
      <td>0.17</td>
      <td>0.65</td>
      <td>0.73</td>
      <td>0.69</td>
  </tr>
  <tr>
    <td><b>Ngrams Model</b></td>
    <td>0.89</td>
    <td>0.77</td>
    <td>0.70</td>
    <td>0.24</td>
    <td>0.76</td>
    <td>0.60</td>
    <td>0.65</td>
</tr>
<tr>
    <td><b>PseAAC Model</b></td>
    <td>0.97</td>
    <td>0.86</td>
    <td>0.78</td>
    <td>0.44</td>
    <td>0.80</td>
    <td>0.25</td>
    <td>0.38</td>
</tr>
<tr>
    <td><b>SVM</b></td>
    <td>0.85</td>
    <td>0.84</td>
    <td>0.83</td>
    <td>0.29</td>
    <td>0.72</td>
    <td>0.67</td>
    <td>0.74</td>
</tr>
<tr>
    <td><b>Holdout</b></td>
    <td>  </td>
    <td>0.78</td>
    <td>0.88</td>
    <td>0.3</td>
    <td>0.69</td>
    <td>0.55</td>
    <td>0.65</td>
</tr>
</table>
<h2 id="js-toc-ignore">Creation of new peptides:</h2>
<p>New peptides were created using a genetic algorithm similar to (ref). Several different metrics were used as loss functions to efficiently generate 10 very different peptides. Due to time restrictions, only two of the 10 were selected to be tested experimentally. 
    These were:
    </p>
<br>
<button type="button" class="collapsible">&darr; Table 5: Peptides Selected to be Tested Experimentally</button>
<table>
  <tr>
    <th> Peptide name </th>
    <th>Sequence</th>
    <th>P(AFP)</th>
    <th>P(NoAMP)</th>
    <th>P(NoAFP-AMP)</th>
  </tr>
  <tr>
    <td><b>WHIPR</b></td>
    <td>KATRIVWWRCEKKIKLLLLEFWHIPRPRFH</td>
    <td>0.91</td>
    <td>0.05</td>
    <td>0.04</td>
  </tr>
  <tr>
    <td><b>MAFP-1</b></td>
    <td>IGKHWKHWAKR</td>
    <td>0.87</td>
    <td>0.08</td>
    <td>0.05</td>
  </tr>
</table>

<p><b>Equation (1)</b> describes the precision in the binary confusion matrix.
</p>
<br>
<p><b>Equation (2)</b> describes the recall in the binary confusion matrix. 
</p>
<br>
<p><b>Equation (3)</b> describes the f1 score in the binary confusion matrix. 
</p>
<br>
<p><b>Equation (4)</b> describes the precision of A in the multilabel confusion matrix.  
</p>
<br>
<p><b>Equation (5)</b> describes the Recall of A in the multilabel confusion matrix. 
</p>
<br>
<p><b>Equation (6)</b> defines the harmonic mean of the AFP precision (here A) and the NoAFPAMP recall (here B). The values for the NoAMP class are denoted by C. See the multilabel confusion matrix for reference.
 </p>
<br>

<p class ="math">
    <dtex>Precision =\frac{TP}{TP + FP}</dtex> 
    <dtex>Recall  =\frac{TP}{TP + FN}</dtex> 
    <dtex>F1Score=\frac{PrecisionxRecall}{Precision+Recall}</dtex>
    <dtex> Recall_{A}=\frac{ Aa }{ Aa+Ab+Ac } </dtex>
    <dtex>HM =\frac{2}{Precision_{ A }^{-1} + Recall_{ B }^{-1}} = \frac{ 2Aa \times Bb }{ 2Aa \times Bb + Aa(Bc+Ba)+Bc(Ca+Ba) } = (1+ \frac{ Ba + Bc }{ Bb } + \frac{ Ba + Ca }{ Aa })^{-1} </dtex>
   </p>
</div>
{% include "partials/footer.nunjucks" %}
</div>

{% endblock %}
